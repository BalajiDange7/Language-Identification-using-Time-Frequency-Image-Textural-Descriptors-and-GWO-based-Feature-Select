# -*- coding: utf-8 -*-
"""RealTime.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1h5fCovJK-yxry3pJnn-5IcR-oNelEVqw
"""

import numpy as np
import scipy.signal
import scipy.io.wavfile
import matplotlib as plot
import matplotlib.pyplot as plt
import os,glob

import numpy as np
import matplotlib.pyplot as plt
import imageio
import skimage
from skimage.color import rgb2gray

import csv
import copy
import os
import sys
import glob




from skimage.feature import local_binary_pattern as lbp
import os,sys,math,cv2
#import numpy as np
import time
from collections import Counter
np.set_printoptions(threshold=np.nan)
import matplotlib.pyplot as plt

path = '/content/'
files = os.listdir(path)
# %matplotlib inline
plt.rc('figure', figsize=(16, 4))

import numpy as np
import scipy.signal
import scipy.io.wavfile
import matplotlib as plot
import matplotlib.pyplot as plt
import os,glob


import imageio
import skimage
from skimage.color import rgb2gray

import csv
import copy
import sys
from sklearn import preprocessing




from skimage.feature import local_binary_pattern as lbp
import sys,math,cv2
import pandas as pd
import time
from collections import Counter
np.set_printoptions(threshold=np.nan)
import matplotlib.pyplot as plt

path = '/content/'
files = os.listdir(path)
# %matplotlib inline
plt.rc('figure', figsize=(16, 4))

for filename in glob.glob(os.path.join(path,'*.wav')):
  
  
  sampling_frequency, wav_data = scipy.io.wavfile.read(filename)
  
  def convert_wav_to_float(data):
      if data.dtype == np.uint8:
          data = (data - 128) / 128.
      elif data.dtype == np.int16:
          data = data / 32768.
      elif data.dtype == np.int32:
          data = data / 2147483648.
      return data

  wav_data = convert_wav_to_float(wav_data)
  n_samples = len(wav_data)
  total_duration = n_samples / sampling_frequency
  sample_times = np.linspace(0, total_duration, n_samples)

  def gaussian_spectrogram(x, fs, window_dur=0.005, step_dur=None, dyn_range=120, 
                           cmap=None, ax=None):
      from scipy.signal import spectrogram, gaussian
      from matplotlib.colors import LogNorm
      from matplotlib.cm import get_cmap

      # set default for step_dur, if unspecified. This value is optimal for Gaussian windows.
      if step_dur is None:
          step_dur = window_dur / np.sqrt(np.pi) / 8.

      # convert window & step durations from seconds to numbers of samples (which is what
      # scipy.signal.spectrogram takes as input).
      window_nsamp = int(window_dur * fs * 2)
      step_nsamp = int(step_dur * fs)

      # make the window. A Gaussian filter needs a minimum of 6σ - 1 samples, so working
      # backward from window_nsamp we can calculate σ.
      window_sigma = (window_nsamp + 1) / 6
      window = gaussian(window_nsamp, window_sigma)

      # convert step size into number of overlapping samples in adjacent analysis frames
      noverlap = window_nsamp - step_nsamp

      # compute the power spectral density
      freqs, times, power = spectrogram(x, detrend=False, mode='psd', fs=fs,
                                        scaling='density', noverlap=noverlap,
                                        window=window, nperseg=window_nsamp)

      p_ref = 2e-5  # 20 μPa, the standard reference pressure for sound in air

      # set lower bound of colormap (vmin) from dynamic range. The upper bound defaults
      # to the largest value in the spectrogram, so we don't need to set it explicitly.
      dB_max = 10 * np.log10(power.max() / (p_ref ** 2))
      vmin = p_ref * 10 ** ((dB_max - dyn_range) / 10)

      # set default colormap, if none specified
      if cmap is None:
          cmap = get_cmap('Greys')
      # or if cmap is a string, get the actual object
      elif isinstance(cmap, str):
          cmap = get_cmap(cmap)

      # create the figure if needed
      if ax is None:
          fig, ax = plt.subplots()
          

      # other arguments to the figure
      extent = (times.min(), times.max(), freqs.min(), freqs.max())

      # plot
      ax.imshow(power, origin='lower', aspect='auto', cmap=cmap,
                norm=LogNorm(), extent=extent, vmin=vmin, vmax=None)
      return ax

  #ax=plt.subplot(111)  
  ax = gaussian_spectrogram(wav_data, sampling_frequency)
  #ax.set_xlabel('time (s)')
  #ax.set_ylabel('frequency (Hz)');
  plt.yticks([])
  plt.xticks([])
  ax.set_ylim(0, 8000)
  ax.set_xlim(0, 4)
  
  ax.figure.savefig('%s.png' % filename)
  
  img1 = imageio.imread('%s.png' % filename)
  gray = skimage.color.rgb2gray(img1)
  crop_img = gray[36:252, 145:1037]
  
  
  



  def binary_to_decimal(lis):
      dec=(2**3)*lis[3]+(2**2)*lis[2]+(2**1)*lis[1]+(2**0)*lis[0]
      return int(dec)

  def compare(pix,center):
      if pix>=center:
          return 1
      else:
          return 0
  def dec2bin(val):
      l=[int(x) for x in bin(val)[2:]]
      b=[0]*(8-len(l))
      b.extend(l)
      dia=b[0::2]
      st=b[1::2]
      return dia,st

  def getlbp(img): 
      neighbours=8
      counter=0
      h,w=img.shape
      im=np.pad(img,((1,1),(1,1)),mode='constant')
      dia_img=np.zeros((h,w),dtype=np.uint8)
      str_img=np.zeros((h,w),dtype=np.uint8)
      for x in range(1,h+1):
          for y in range(1,w+1):
      #         center=img[i,j]
              dia=[]
              hor=[]
              for counter in range(0,neighbours):
                  if counter == 0:
                      dia.append(compare(im[x-1,y-1], im[x,y]))
                  elif counter == 1:
                      hor.append(compare(im[x,y-1], im[x,y]))
                  elif counter == 2:
                      dia.append(compare(im[x+1,y-1], im[x,y]))
                  elif counter == 3:
                      hor.append(compare(im[x+1,y], im[x,y]))
                  elif counter == 4:
                      dia.append(compare(im[x+1,y+1], im[x,y]))
                  elif counter == 5:
                      hor.append(compare(im[x,y+1], im[x,y]))
                  elif counter == 6:
                      dia.append(compare(im[x-1,y+1], im[x,y]))
                  elif counter == 7:
                      hor.append(compare(im[x-1,y], im[x,y]))
              dia_img[x-1,y-1]=binary_to_decimal(dia)
              str_img[x-1,y-1]=binary_to_decimal(hor)
      return dia_img,str_img                
  # def getlbp(img): 
  #     neighbours=8
  #     h,w=img.shape
  #     img=lbp(image=img,P=neighbours,R=1)
  #     dia_img=np.zeros((h,w),dtype=np.uint8)
  #     str_img=np.zeros((h,w),dtype=np.uint8)
  #     for x in range(0,h):
  #         for y in range(0,w):
  #     #         center=img[i,j]
  #             dia,hor=dec2bin(int(img[x][y]))
  #             dia_img[x,y]=binary_to_decimal(dia)
  #             str_img[x,y]=binary_to_decimal(hor)
  #     return dia_img,str_img 

  def get090(arr):
      list0=[]
      list90=[]
      y,x=arr.shape
      for i in range(y):
          for j in range(x):
      #         print(i,j)
              try:
                  list0.append((arr[i][j],arr[i][j+1]))
              except:
                  pass
              try:
      #             print(arr[j,i],arr[j,i+1])
                  list90.append((arr[j][i],arr[j+1][i]))

  #                 print(arr[j,i],arr[j+1,i])

              except:
                  continue
      return list0,list90


  def get45135(arr):
  #     print(np.where(arr==0))
      list45=[]
      list135=[]
      y,x=arr.shape
      for i in range(y):
          for j in range(x):
              try:
                  list135.append((arr[i][j],arr[i+1][j+1]))
              except Exception as e:
                  pass
              try:
                  if (j-1)>=0:
                      list45.append((arr[i][j],arr[i+1][j-1]))

              except Exception as e:
                  pass

      return list45,list135

  def groupandcount(lis):
      lis=[(item[1],item[0]) if item[0]>item[1] else (item[0],item[1]) for item in lis]
  #     print(len(set(lis)))
      counts = dict()
      for i in lis:
        counts[i] = counts.get(i, 0) + 1
      return counts

  def getfeatures(image):
      # t1=time.time()
      im1,im2=getlbp(image)
      # print(time.time()-t1)
      list0,list90=get090(im2)
      a,b=im1.shape
      list45,list135=get45135(im1)
      tot=[]
      tot.extend(list0)
      tot.extend(list45)
      tot.extend(list90)
      tot.extend(list135)
      val=groupandcount(tot)
      bins=[(i,j) for i in range(16) for j in range(16) if i<=j]
      features=['_']*len(bins)
      # print(len(features))
      for idx,i in enumerate(bins):
          # print(idx)
          try:
              features[idx]=val[i]
          except Exception as e:
              features[idx]=0
      return features       
  # print(len(bins))
  # print(sorted(list0,key=lambda x:(x[0],x[1])))
  features = getfeatures(crop_img)
  with open("features.csv", 'a') as f:
    writer = csv.writer(f)
    writer.writerow(features)

from keras.models import Sequential
from keras.layers import Dense
from sklearn.model_selection import train_test_split

x_train = pd.read_csv('/content/featuresL3xtrain.csv')
y_train = pd.read_csv('/content/featureL3ytrain.csv')
x_test = pd.read_csv('/content/featuresL3xtest.csv')
y_test = pd.read_csv('/content/featureL3ytest.csv')
x_train = preprocessing.normalize(x_train)
x_test = preprocessing.normalize(x_test)

print(x_train.shape,x_test.shape)

from keras.utils import np_utils

n_classes=3

y_orig = y_test
print("Shape before one-hot encoding",y_train.shape)
y_train=np_utils.to_categorical(y_train,n_classes)
y_test=np_utils.to_categorical(y_test,n_classes)
print("Shape after one-hot encoding",y_train.shape)

from keras.models import Sequential
from keras.layers.core import Dense,Activation

model= Sequential()
model.add(Dense(136,input_shape=(136,)))
model.add(Activation('relu'))
model.add(Dense(3))
model.add(Activation('softmax'))

#compile the model
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

#training deep neural network
history= model.fit(x_train,y_train,batch_size=10,epochs=30,validation_data=[x_test,y_test])

scores = model.evaluate(x_test, y_test)
print("Accuracy: %.2f%%" % (scores[1]*100))





x_test = pd.read_csv('/content/features.csv')
x_test = preprocessing.normalize(x_test)

y_pred= model.predict_classes(x_test)

#i_i = np.nonzero(y_pred != y_orig)[0]
#a=i_i[0]

if y_pred == 0:
  print("Spoken language is Bengali")
elif y_pred == 1:
  print("Spoken language is Marathi")
elif y_pred == 2:
  print("Spoken language is Malayalam")
else:
  print("")

